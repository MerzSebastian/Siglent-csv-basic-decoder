# Author: Sebastian Merz
# Licence: GNU General Public License v3.0
# Description: Script for testing the decode.py script and making sure that it doesnt break
# Example: test.py

import os
import glob
from expect import Expect
import pathlib
import json

basePath = os.path.dirname(pathlib.Path().resolve())
mainPath = os.path.join(basePath, 'src\decode.py')
inputPath = os.path.join(basePath, 'test\samples')
outputPath = os.path.join(basePath, 'test\output')
startCommand = ' '.join([mainPath, inputPath, outputPath])

print("TEST: Starting test")
print("TEST: config:")
print("TEST: main path:", mainPath)
print("TEST: input path", inputPath)
print("TEST: output path", outputPath)
print("TEST: start command", startCommand)

os.system(startCommand)
files = glob.glob(os.path.join(outputPath, '*json'))
if not files:
    raise ValueError('No output files!')
newest_file = max(files, key=os.path.getctime)
result = json.loads(open(newest_file, "r").read())

print("TEST: Testing: usr_wf_data_0.bin")
file = result["usr_wf_data_0.bin"]
Expect(file["detectionThreshold"]).to_be("0.300000000000", "JSON should have correct detectionThreshold")
Expect(file["singlePulseLength"]).to_be("0.000000297000", "JSON should have correct singlePulseLength")
Expect(file["maxError"]).to_be("0.000000797000", "JSON should have correct maxError")
Expect(file["avgError"]).to_be("0.000000217857", "JSON should have correct avgError")
Expect(file["dataPointsRaw"]).to_be(700000, "JSON should have correct dataPointsRaw")
Expect(file["data"]["bin"]).to_be("100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001", "JSON should have correct binary data")
Expect(file["data"]["size"]).to_be(1149, "JSON should have correct data size")
Expect(len(file["data"]["bin"])).to_be(file["data"]["size"], "JSON should have correct amount of bits")
Expect(len(file["data"]["times"])).to_be(file["data"]["size"], "JSON should have correct amount of times") #problem with inlcuded leading and trailing zeros
Expect(len(file["data"]["errors"])).to_be(file["data"]["size"], "JSON should have correct amount of errors")

print("TEST: Testing: usr_wf_data_1.bin")
file = result["usr_wf_data_1.bin"]
Expect(file["detectionThreshold"]).to_be("0.300000000000", "JSON should have correct detectionThreshold")
Expect(file["singlePulseLength"]).to_be("0.000000297000", "JSON should have correct singlePulseLength")
Expect(file["maxError"]).to_be("0.000000030000", "JSON should have correct maxError")
Expect(file["avgError"]).to_be("0.000000014821", "JSON should have correct avgError")
Expect(file["dataPointsRaw"]).to_be(700000, "JSON should have correct dataPointsRaw")
Expect(file["data"]["bin"]).to_be("100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001", "JSON should have correct binary data")
Expect(file["data"]["size"]).to_be(1149, "JSON should have correct data size")
Expect(len(file["data"]["bin"])).to_be(file["data"]["size"], "JSON should have correct amount of bits")
Expect(len(file["data"]["times"])).to_be(file["data"]["size"], "JSON should have correct amount of times") #problem with inlcuded leading and trailing zeros
Expect(len(file["data"]["errors"])).to_be(file["data"]["size"], "JSON should have correct amount of errors")

print("TEST: Testing: usr_wf_data_2.bin")
file = result["usr_wf_data_2.bin"]
Expect(file["detectionThreshold"]).to_be("0.300000000000", "JSON should have correct detectionThreshold")
Expect(file["singlePulseLength"]).to_be("0.000000297000", "JSON should have correct singlePulseLength")
Expect(file["maxError"]).to_be("0.000000796000", "JSON should have correct maxError")
Expect(file["avgError"]).to_be("0.000000216709", "JSON should have correct avgError")
Expect(file["dataPointsRaw"]).to_be(700000, "JSON should have correct dataPointsRaw")
Expect(file["data"]["bin"]).to_be("10001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111010001000100010001000100010001000100010001000100010001000100010001110111011101110111011101110111", "JSON should have correct binary data")
Expect(file["data"]["size"]).to_be(1151, "JSON should have correct data size")
Expect(len(file["data"]["bin"])).to_be(file["data"]["size"], "JSON should have correct amount of bits")
Expect(len(file["data"]["times"])).to_be(file["data"]["size"], "JSON should have correct amount of times") #problem with inlcuded leading and trailing zeros
Expect(len(file["data"]["errors"])).to_be(file["data"]["size"], "JSON should have correct amount of errors")

#for file in os.listdir(outputPath):
#    os.remove(os.path.join(outputPath, file))
